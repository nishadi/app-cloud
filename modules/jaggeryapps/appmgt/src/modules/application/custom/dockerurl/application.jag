<%
/*
 * Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 *   WSO2 Inc. licenses this file to you under the Apache License,
 *   Version 2.0 (the "License"); you may not use this file except
 *   in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing,
 *   software distributed under the License is distributed on an
 *   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *   KIND, either express or implied.  See the License for the
 *   specific language governing permissions and limitations
 *   under the License.
 */

include("/jagg/jagg.jag");
include("/jagg/constants.jag");

var log = new Log("module/application/custom/dockerurl/application.jag");
var modManager = jagg.module("manager");
var appManager = jagg.module("application");
var ApplicationManager = Packages.org.wso2.appcloud.core.ApplicationManager;
var Application = Packages.org.wso2.appcloud.core.dto.Application;
var CustomTransport = Packages.org.wso2.appcloud.core.dto.CustomTransport;
var Version = Packages.org.wso2.appcloud.core.dto.Version;
var KubernetesProvisioningUtils =  Packages.org.wso2.appcloud.provisioning.runtime.Utils.KubernetesProvisioningUtils;
var EventsManager = Packages.org.wso2.appcloud.core.EventsManager;
var Event = Packages.org.wso2.appcloud.core.dto.Event;
var Deployment = Packages.org.wso2.appcloud.core.dto.Deployment;
var Container = Packages.org.wso2.appcloud.core.dto.Container;
var ServiceProxy = Packages.org.wso2.appcloud.core.dto.ContainerServiceProxy;
var CloudUtil = Packages.org.wso2.appcloud.common.util.AppCloudUtil;
var RuntimeProperty = Packages.org.wso2.appcloud.core.dto.RuntimeProperty;
var CarbonUtils = Packages.org.wso2.carbon.utils.CarbonUtils;
var Util = Packages.org.wso2.appcloud.core.Util;

/**
 * Add an application via Docker URL
 *
 */

var addApplicationViaDockerUrl = function (applicationName, versionName, applicationDescription, replicas, runtimePropertiesArray,
                                           dockerUrl, imageTag, httpPort, httpsPort, tagArray, appIcon,isNewVersion) {

    var appTypeName = "custom";
    log.info("Started creating App => name : " + applicationName + " Version : " + versionName + " Description " +
             ": " + applicationDescription + " apptype : " + appTypeName + " Docker url: "
                     + dockerUrl+":"+imageTag);

    var tenantId = modManager.getTenantId();
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    var versionHashId = Util.getVersionHashId(applicationName, versionName, tenantId);


    if(isNewVersion == 'true'){
        createAppVersionInDataBase(versionName, tagArray, applicationHashId, versionHashId);
    }else{
        createAppInDataBase(applicationName, versionName, applicationDescription, replicas, appTypeName,
                 tagArray, appIcon, applicationHashId, versionHashId);
    }

    createCustomTransport(versionHashId, 'http', httpPort);
    createCustomTransport(versionHashId, 'https', httpsPort);

    var tagName = imageTag +"-"+ versionHashId;
    var DockerOpClient = Packages.org.wso2.appcloud.core.docker.DockerOpClient;
    var dockerOpClient = new DockerOpClient(modManager.getPropertyValue("DockerClientURL"));
    var runtimeProperties = generateRuntimePropsList(runtimePropertiesArray);

    pullDockerImage(applicationName, versionName, dockerUrl, imageTag, versionHashId,dockerOpClient);
    tagDockerImage(dockerUrl, imageTag, tagName, versionHashId, dockerOpClient);
    pushDockerImage(applicationName, versionName, dockerUrl, imageTag, tagName, versionHashId, dockerOpClient);
    triggerKubernetesDeployment(runtimeProperties, tagName,dockerUrl, applicationName, versionName, replicas, versionHashId, httpPort, httpsPort);
};


var pullDockerImage =  function(applicationName, versionName, dockerUrl, imageTag, versionHashId, dockerOpClient){
   //Adding docker image pull pending event
    var msg = "Docker image pull successfully triggered in appcloud";
    appManager.addEvent(DOCKER_IMAGE_PULL, EVENT_PENDING, msg,  versionHashId);

    try {
        dockerOpClient.pullDockerImage(dockerUrl,imageTag);
    } catch (e){
        var msg = "Error while pulling docker image";
        appManager.addEvent(DOCKER_IMAGE_PULL, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                    + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because docker image pull failed and roll back process" +
                " is started for application : "+applicationName+" with revision : "+versionName);
        appManager.deleteVersionFromDatabase(versionHashId);
        throw e;
    }
    //Adding docker pull success event
    var msg = "Docker image pull successfull";
    appManager.addEvent(DOCKER_IMAGE_PULL, EVENT_SUCCEEDED, msg, versionHashId);
}

var tagDockerImage =  function(dockerUrl, imageTag, newTag, versionHashId, dockerOpClient){

    var msg = "Docker custom image tag successfully triggered in appcloud";
    appManager.addEvent(DOCKER_IMAGE_TAG, EVENT_PENDING, msg,  versionHashId);

    try {
        dockerOpClient.tagDockerImage(dockerUrl, imageTag, modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL),newTag);
    } catch (e){
        var msg = "Error while tagging docker image";
        appManager.addEvent(DOCKER_IMAGE_TAG, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while tagging docker image Application Creation Failed event for application : " + applicationName
                    + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because docker image tag failed and roll back process" +
                " is started for application : "+applicationName+" with revision : "+versionName);
        appManager.deleteVersionFromDatabase(versionHashId);
        throw e;
    }
    //Adding docker pull success event
    var msg = "Docker image tag successfull";
    appManager.addEvent(DOCKER_IMAGE_TAG, EVENT_SUCCEEDED, msg, versionHashId);
}

var pushDockerImage = function (applicationName, versionName, dockerUrl, imageTag, tagName, versionHashId, dockerOpClient){

    //Adding docker image push pending event
    var msg = "Docker image push successfully triggered in triggered";
    appManager.addEvent(DOCKER_REGISTRY_PUSH, EVENT_PENDING, msg, versionHashId);

    try {
        dockerOpClient.pushDockerImage(modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL), dockerUrl, tagName);

    } catch (e) {

        var msg = "Error uploading docker image to remote registry";
        appManager.addEvent(DOCKER_REGISTRY_PUSH, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                    + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because docker image push failed and roll back process" +
                " is started for application : "+applicationName+" with revision : "+versionName);
        deleteVersion(versionHashId, true, false);
        throw e;
    }

    //Adding docker push success event
    var msg = "Docker image push successfully completed";
    appManager.addEvent(DOCKER_REGISTRY_PUSH, EVENT_SUCCEEDED, msg, versionHashId);
}

var triggerKubernetesDeployment = function(runtimeProperties, tagName, dockerUrl, applicationName, versionName, replicas, versionHashId, httpPort, httpsPort){
    var appHostURL = constructAppLaunchURL(applicationName, versionName);
    var containers = getContainers(modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL), dockerUrl, tagName, versionHashId ,versionHashId, runtimeProperties, appHostURL, httpPort, httpsPort);
    var deploymentConfig = getDeploymentConfig(containers, versionHashId, replicas);
    deployApplication(applicationName, versionName, deploymentConfig, false, versionHashId);

}

function getDeploymentConfig(containersList, versionHashId, replicas){

    var deploymentConfig = new Packages.org.wso2.appcloud.provisioning.runtime.beans.DeploymentConfig();
    deploymentConfig.setDeploymentName(versionHashId);
    deploymentConfig.setReplicas(parseInt(replicas));
    deploymentConfig.setContainers(containersList);

    return deploymentConfig;
}
var constructAppLaunchURL = function(applicationName, versionName){

    applicationName = Util.getRuntimeValidAppName(applicationName);
    applicationName = applicationName.toLowerCase();

    var urlPrefix = modManager.getTenantDomain()
            + "-" + applicationName + "-" + versionName;
    var appLaunchURL = urlPrefix.replace(/\./g, '-')
            +  "." + modManager.getPropertyValue("ApplicationLaunchBaseURL");

    log.info("Application Launch URL: " + appLaunchURL);

    return appLaunchURL;
};

var deployApplication = function(applicationName, versionName, deploymentConfig, isRedeploy, versionHashId){

    //Adding deployment pending event
    var msg = "Application deployment successfully triggered in Kubernetes";
    appManager.addEvent(KUBE_DEPLOY, EVENT_PENDING, msg, versionHashId);

    applicationName = Util.getRuntimeValidAppName(applicationName);
    //Creating basic deployment
    var KubernetesRuntime = Packages.org.wso2.appcloud.provisioning.runtime.KubernetesRuntimeProvisioningService;

    var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(
            applicationName, versionName, null , modManager.getTenantId(), modManager.getTenantDomain(), versionHashId);
    var kubService = new KubernetesRuntime(applicationCtx);
    //log.info(Util.class.getName());
    log.info("Deploying application: " + applicationName);
    try{
        kubService.deployApplication(deploymentConfig);
        if(!isRedeploy) {
            persistDeploymentConfig(deploymentConfig, versionHashId);
        }

    } catch(e){
        var msg = "Error while submitting application deployment to Kubernetes";
        appManager.addEvent(KUBE_DEPLOY, EVENT_FAILED, msg, versionHashId);
        ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        log.error(msg);
        log.error(e);
        log.info("Application deployment failed because kubernetes deployment was failed and roll back process" +
                " is started for application:"+applicationName+" with revision:"+versionName);
        deleteVersion(versionHashId, true, false);
        throw e;
    }
    //Adding deployment success event
    var msg = "Application deployment successfull";
    appManager.addEvent(KUBE_DEPLOY, EVENT_SUCCEEDED, msg, versionHashId);
    //============================================================================================================

    //======================================= Creating Ingress ===================================================
    //Adding deployment pending event
    var msg = "Application ingress creation successfully triggered in Kubernetes";
    appManager.addEvent(INGRESS, EVENT_PENDING, msg, versionHashId);
    try{
        var appLaunchURL = constructAppLaunchURL(applicationName, versionName);

        var ingressCreated = kubService.createDeploymentUrl(appLaunchURL);
        log.info("Deployment URL status: " + ingressCreated);
        var msg = "Application ingress creation successful";
        appManager.addEvent(INGRESS, EVENT_SUCCEEDED, msg, versionHashId);
    } catch(e){
        var msg = "Application ingress creation failed in Kubernetes";
        appManager.addEvent(INGRESS, EVENT_FAILED, msg, versionHashId);
        ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        log.info("Application deployment failed because ingress is not created successfully and roll back process" +
                " is started for application:"+applicationName+" with revision:"+versionName);
        deleteVersion(versionHashId, true, true);
        log.error(msg);
        log.error(e);
        throw e;
    }
    //======================================= checking pod status =================================================
    //Adding pod status pending event
    var msg = "Application pods Scheduled";
    var podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
    var prevPodStatus = "";
    appManager.addEvent(POD_STATUS, EVENT_PENDING, podStatus, versionHashId);

    var timeOut = modManager.getPropertyValue(POD_TIMEOUT);
    var counter = 0;
    while(counter < timeOut){ // Waiting 5 minutes to gets pods up and running
        java.lang.Thread.sleep(1000);
        var podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
        counter = counter + 1;
        if (podStatus == "Running") {
            //Adding pod status pending event
            var msg = "Application started successfully";
            appManager.addEvent(POD_STATUS, EVENT_SUCCEEDED, podStatus, versionHashId);
            ApplicationManager.updateVersionStatus(versionHashId,APPLICATION_RUNNING);
            break;
        }else if(counter == timeOut){ // if pods doesn't starts withing 5 minutes user redirected to user home
            //Adding pod status error event
            var msg = "Application starting failed";
            var podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
            appManager.addEvent(POD_STATUS, EVENT_FAILED, podStatus, versionHashId);
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
            log.info("Application rollback started for application:"+applicationName + " with revision:"+
                    versionName +" because pods are not running even after 3 minutes.");
            deleteVersion(versionHashId, true, true);
        } else {
            var podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
            if (podStatus !== prevPodStatus) {
                appManager.addEvent(POD_STATUS, EVENT_PENDING, podStatus, versionHashId);
                prevPodStatus = podStatus;
            }
        }
    }
};
var deleteVersion = function(versionHashId, isAutoDelete, isDeployed){
    if(!isAutoDelete) {
        deleteApplicationUploadedPath(versionHashId);
    }
    if(isDeployed) {
        deleteApplicationFromKubernetes(versionHashId);
        deleteEventsOfAppVersions(versionHashId);
    }

    var applicationHashId = ApplicationManager.getApplicationHashIdByVersionHashId(versionHashId);
    deleteSelectedVersionFromSession(applicationHashId);
    deleteVersionFromDatabase(versionHashId, applicationHashId);
};
var deleteApplicationUploadedPath = function(versionHashId) {

    var fileUploadPath = getVersionDirectoryPath(versionHashId);
    var fileUtils = Packages.org.apache.commons.io.FileUtils;
    var uploadedFile = new Packages.java.io.File(fileUploadPath);

    if(uploadedFile.exists()){
        fileUtils.deleteDirectory(uploadedFile);

    }
};
var persistDeploymentConfig = function(deploymentConfig, versionHashId){

    var containerList = deploymentConfig.getContainers();
    var ctr = containerList.get(0);
    var serviceProxies = ctr.getServiceProxies();
    var svc = serviceProxies.get(0);

    var deployment = new Deployment();
    deployment.setDeploymentName(deploymentConfig.getDeploymentName());
    log.info("Deployment name:" + deploymentConfig.getDeploymentName());
    deployment.setReplicas(parseInt(deploymentConfig.getReplicas()));
    log.info("Replicas:" + deploymentConfig.getReplicas());

    var serviceProxy = new ServiceProxy();
    serviceProxy.setServiceName(svc.getServiceName());
    log.info("Service name:" + svc.getServiceName());
    serviceProxy.setServiceProtocol(svc.getServiceProtocol());
    log.info("Service protocol:" + svc.getServiceProtocol());
    serviceProxy.setServicePort(svc.getServicePort());
    log.info("Service port:" + svc.getServicePort());
    serviceProxy.setServiceBackendPort(svc.getServiceBackendPort());
    log.info("Service Backend Port:" + svc.getServiceBackendPort());

    var container = new Container();
    container.setImageName(ctr.getBaseImageName());
    log.info("Image name:" + ctr.getBaseImageName());
    container.setImageVersion(ctr.getBaseImageVersion());
    log.info("Image version:" + ctr.getBaseImageVersion());

    var proxies = new java.util.HashSet();
    proxies.add(serviceProxy);
    container.setServiceProxies(proxies);

    var containerSet = new java.util.HashSet();
    containerSet.add(container);
    deployment.setContainers(containerSet);
    ApplicationManager.addDeployment(versionHashId, deployment );
};
var deleteEventsOfAppVersions = function(versionHashId){
    var eventsManager = new EventsManager();
    eventsManager.deleteAllEventsofAppVersion(versionHashId);
};

var deleteSelectedVersionFromSession = function(applicationKey){
    var selectedVersions = session.get("SELECTED_REVISIONS");
    if(selectedVersions && selectedVersions[applicationKey]){
        delete selectedVersions[applicationKey];
    }
};


var deleteApplicationFromKubernetes = function(versionHashId) {

    try{
        var KubernetesRuntimeProvisioningService = Packages.org.wso2.appcloud.provisioning.runtime.KubernetesRuntimeProvisioningService;
        var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(null, null, null, modManager.getTenantId(),
                modManager.getTenantDomain(), versionHashId);
        var kubernetesRuntimeProvisioningService = new KubernetesRuntimeProvisioningService(applicationCtx);
        kubernetesRuntimeProvisioningService.deleteDeployment();

    } catch(e){
        log.error("Error while cleaning up the Kubernetes deployment for the version with hash id : " + versionHashId);
        log.error(e);
    }
};

var deleteVersionFromDatabase = function(versionHashId, applicationHashId) {
    try{
        if(ApplicationManager.isSingleVersion(versionHashId)){
            ApplicationManager.deleteApplication(applicationHashId);
        } else {
            ApplicationManager.deleteVersion(versionHashId);
        }
    }catch(e){
        log.error("Error while deleting application version from the database with version hash id : " + versionHashId);
        log.error(e);
    }
};

var deleteApplicationFromDatabase = function (applicationHashId){
    try {
        ApplicationManager.deleteApplication(applicationHashId);
    } catch(e){
        log.error("Error while deleting application from the database with application hash id : " + applicationHashId);
        log.error(e);
    }
};

/**
 * Method for getting all the available application types.
 */
function getContainers(tenantDockerRegistryUrl, baseImageName, tag, versionHashId, appServiceName, runtimeProperties, appHostURL){
    var containerList = new java.util.ArrayList();
    var container = new Packages.org.wso2.appcloud.provisioning.runtime.beans.Container();
    var appBaseImageName = tenantDockerRegistryUrl + "/" + baseImageName;
    container.setContainerName(versionHashId);
    container.setBaseImageName(appBaseImageName);
    container.setBaseImageVersion(tag);
    var envs = getRuntimeProperties(runtimeProperties);
    container.setEnvVariables(envs);
    var serviceProxyList = new java.util.ArrayList();
    var services = ApplicationManager.getTransportsForCustomApplication(versionHashId);

    for(var i = 0; i < services.length; i++){
        var serviceProxy = new Packages.org.wso2.appcloud.provisioning.runtime.beans.ServiceProxy();
        var service = services[i];
        serviceProxy.setServiceName('srv-' + appServiceName);
        serviceProxy.setAppHostURL(appHostURL);
        serviceProxy.setServiceProtocol(service.getServiceProtocol());
        serviceProxy.setServicePort(getIngressPort(service.getServiceName()));
        serviceProxy.setServiceBackendPort(service.getServicePort());
        serviceProxyList.add(serviceProxy);
    }
    container.setServiceProxies(serviceProxyList);
    containerList.add(container);

    return containerList;
};

var getIngressPort = function(serviceName){

    if(serviceName == "http" || serviceName == "http-alt"){
        return  80;
    }else if(serviceName == "https" || serviceName == "https-alt"){
        return 443;
    } else{
        return 443;
    }
};

function getRuntimeProperties(runtimeProperties){
    //setting runtime properties to the container
    var envs = new java.util.HashMap();
    if(runtimeProperties) {
        var runtimePropertyIterator = runtimeProperties.iterator();
        while (runtimePropertyIterator.hasNext()) {
            var runtimeProperty = runtimePropertyIterator.next();
            envs.put(runtimeProperty.getPropertyName(), runtimeProperty.getPropertyValue());
        }
    }
    return envs;
}

var createCustomTransport = function(versionHashId, portName, port){
    var customTransport = new CustomTransport();
    try {
        customTransport.setVersionHashId(versionHashId);
        customTransport.setName(portName);
        customTransport.setProtocol('TCP');
        customTransport.setPort(port);

        ApplicationManager.addTransportsForCustomApplication (customTransport);

    }catch (e){

        var msg = "Error while adding application port details to database";
        appManager.addEvent(DATABASE_CUSTOM_TRANSPORT_ADD, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch (e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                    + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because initial application metadata persistence failed and roll back process" +
                " is started for application : "+applicationName+" with version : "+ versionName);
        throw e;
    }
}

var createAppInDataBase = function(applicationName, versionName, applicationDescription, replicas,
                                   appTypeName,  tagArray, appIcon, applicationHashId, versionHashId){

    //================================= Adding application to Database =========================================
    var application = new Application();
    var version = new Version();

    try {
        application.setApplicationName(applicationName);
        application.setHashId(applicationHashId);
        application.setDescription(applicationDescription);
        application.setApplicationType(appTypeName);

        var iconStream = null;
        var iconBlob = null;
        if (appIcon) {
            iconStream = Packages.org.apache.commons.io.IOUtils.toByteArray(appIcon.getStream().getStream());
            iconBlob = new Packages.javax.sql.rowset.serial.SerialBlob(iconStream);
            application.setIcon(iconBlob);
        }

        version.setVersionName(versionName);
        version.setRuntimeId(6);
        version.setStatus(APPLICATION_CREATED);
        version.setHashId(versionHashId);

        <!--if(runtimePropertiesArray.length > 0) {-->
            <!--var runtimePropertyList = generateRuntimePropsList(runtimePropertiesArray);-->
            <!--version.setRuntimeProperties(runtimePropertyList);-->
        <!--}-->

        if(tagArray.length > 0){
            var tagList = generateTagsList(tagArray);
            version.setTags(tagList);
        }

        var versionList = new java.util.ArrayList();
        versionList.add(version);
        application.setVersions(versionList);

        ApplicationManager.addApplication(application);

    } catch (e){

        var msg = "Error while adding application to database";
        appManager.addEvent(DATABASE_ADD, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch (e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                    + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because initial application metadata persistence failed and roll back process" +
                " is started for application : "+applicationName+" with version : "+ versionName);
        deleteApplicationUploadedPath(versionHashId);
        throw e;
    }
    return application;
}

var createAppVersionInDataBase = function( versionName, tagArray, applicationHashId, versionHashId){
    var version = new Version();
    try {
        version.setVersionName(versionName);
        version.setRuntimeId(6);
        version.setStatus(APPLICATION_CREATED);
        version.setHashId(versionHashId);

        if(tagArray.length > 0){
            var tagList = generateTagsList(tagArray);
            version.setTags(tagList);
        }
        ApplicationManager.addApplicationVersion(version, applicationHashId);

    } catch (e){
        var msg = "Error while adding application version to database";
        appManager.addEvent(DATABASE_ADD, EVENT_FAILED, msg, versionHashId);
        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch (e1){
            log.error("Error while updating Application version Creation Failed event for application hash id : " + applicationHashId
                    + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application version creation failed because initial application metadata persistence failed and roll back process" +
                " is started for application hash id : "+applicationHashId+" with version : "+ versionName);
        // deleteApplicationUploadedPath(applicationName, versionName);
        throw e;
    }
    return version;
}

var generateRuntimePropsList = function (runtimePropsArray) {
    try {
        var size = runtimePropsArray.length;
        var propsList = new java.util.ArrayList();
        for (var i = 0; i < size; i++) {
            var runtimePropJsonObj = runtimePropsArray[i];
            var runtimeProperty = new RuntimeProperty();
            runtimeProperty.setPropertyName(runtimePropJsonObj.key);
            runtimeProperty.setPropertyValue(runtimePropJsonObj.value);
            propsList.add(runtimeProperty);
        }
        return propsList;
    } catch (e) {
        log.error("Error while adding runtime props : ");
        log.error(propsList);
        log.error(e);
        throw e;
    }
};

%>